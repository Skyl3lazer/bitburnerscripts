/** @param {NS} ns **/
import { Server } from "scanall.ns"
export async function main(ns) {
	ns.disableLog("sleep");
	ns.disableLog("getHackingLevel");
	ns.disableLog("getServerMoneyAvailable");
	ns.disableLog("getServerSecurityLevel");
	ns.tail();
	/*
	Port Mapping:
	Port 1 = Output Order objects
	Port 2 = Input threads put on target
	Port 3 = Input completed orders
	*/
	ns.clearPort(1);
	ns.clearPort(2);
	ns.clearPort(3);
	ns.run("/hack/client.ns");
	//Configuration
	var weight_maxMoney = 10;
	var weight_growth = 2000000;
	var securityThresh = 0; //Don't hack if security is below this threshhold (plus base min)
	var moneyThresh = .65; //Don't hack if money is below maxMoney * moneyThresh
	var maxConcurrent = 5; //Maximum amount of servers you want to concurrently be trying to hack (starting with most efficient)
	var hackThreadThresh = 15000; //Won't run more than this many hack threads at once
	var batchOffset = 500;//ms to delay between batches in a hwgw
	//End Configuration

	var ImportServers = JSON.parse(ns.read("serverlist.txt"));
	var orderQueue = new Array();
	var nextOrderID = 1;
	var totalweight = weight_maxMoney + weight_growth;
	weight_maxMoney /= totalweight;
	weight_growth /= totalweight;

	//filter unwanted servers
	var exclude = ["home", "n00dles", "darkweb", "CSEC", "avmnite-02h", "I.I.I.I", "run4theh111z", ".", "The-Cave"];
	var servers = ImportServers.filter(function (server) {
		return !exclude.includes(server.name) && !server.name.startsWith("pserv");
	});

	//main loop
	while (true) {
		//read any order acceptance squaks
		let portData = ns.readPort(2);
		while (portData !== "NULL PORT DATA") {
			portData = JSON.parse(portData);
			const ord = orderQueue.find(element => element.id === portData.id);
			if (ord === undefined) {
				portData = ns.readPort(2);
				continue;
			}
			if (portData.startedThreads < ord.neededThreads) {
				if (portData.startedThreads > 0) {
					ns.print("ID " + ord.id + ": " + "Only " + portData.startedThreads + " of needed " + ord.neededThreads + " were started. Requesting " + (ord.neededThreads - portData.startedThreads));
				}
				let writeCheckSquak = false;
				ord.neededThreads -= portData.startedThreads;
				while (!writeCheckSquak) {
					writeCheckSquak = await ns.tryWritePort(1, JSON.stringify(ord));
					await ns.sleep(5);
				}
			} else {
				ns.print("ID " + ord.id + " " + ord.type + " " + ord.target.name + ": Started all " + ord.threads + " threads.");
			}
			portData = ns.readPort(2);
		}
		//read any order completion squaks
		portData = ns.readPort(3);
		while (portData !== "NULL PORT DATA") {
			portData = JSON.parse(portData);
			const ord = orderQueue.find(element => element.id === portData.id);
			if (ord === undefined) {
				portData = ns.readPort(3);
				continue;
			}
			if ((ord.neededThreads - portData.threads) > 0) {
				ord.neededThreads -= portData.threads;
				ns.print("ID " + ord.id + " " + ord.type + " " + ord.target.name + ": Completed " + (ord.threads - ord.neededThreads) + " of " + ord.threads + " threads.");
			} else {

				let updateSrv = ImportServers.find(function (server) { return server.name === portData.server.name });
				updateSrv = portData.server;
				ns.print("ID " + ord.id + " " + ord.type + " " + ord.target.name + ": Completed.");
				orderQueue.splice(orderQueue.indexOf(orderQueue.find(element => element.id == portData.id)), 1);
			}

			portData = ns.readPort(3);
		}
		//write a new order
		let distictTargets = new Set(orderQueue.map(x => x.target.name)).size;
		if (distictTargets < maxConcurrent) {
			let orders = await determineOrder();
			if (orders !== "NO ORDER") {
				for (let order of orders) {
					let writeCheckNew = await ns.tryWritePort(1, JSON.stringify(order));
					ns.print("Writing Order " + order.id + ": " + order.type + " " + order.target.name);
					while (!writeCheckNew) {
						await ns.sleep(5);
						writeCheckNew = await ns.tryWritePort(1, JSON.stringify(order));
					}
					orderQueue.push(order);
				}
			}
		}
		await ns.write("orderqueue.txt", JSON.stringify(orderQueue), "w");
		await ns.write("serverlist.txt", JSON.stringify(ImportServers), "w");
		servers = ImportServers.filter(function (server) {
			return !exclude.includes(server.name) && !server.name.startsWith("pserv");
		});
		await ns.sleep(1000);
	}

	//Determine the order to send next
	async function determineOrder() {
		let hackLevel = ns.getHackingLevel();
		let hackableServers = servers.filter(function (server) {
			return server.hackLevel <= hackLevel && orderQueue.every(function (order) {
				return order.target.name !== server.name;
			}) && server.hasRoot;
		});
		if (hackableServers.length === 0) {
			return Promise.resolve("NO ORDER");
		}
		let highScore = 0;
		let highTarget = new Server();
		let threads = 0;
		let type = "";
		hackableServers.forEach(server => {
			server.money = ns.getServerMoneyAvailable(server.name);
			server.security = ns.getServerSecurityLevel(server.name);
			let score = (server.maxMoney * weight_maxMoney) + (server.growth * weight_growth);
			server.hackTime = ns.getHackTime(server.name);
			score /= server.hackTime;
			if (score > highScore) {
				highScore = score;
				highTarget = server;
			}
		});
		if (highTarget.name === undefined) {
			return Promise.resolve("NO ORDER");
		}
		if (highTarget.security > highTarget.minSec + securityThresh) {
			type = "w";
			threads = Math.ceil((highTarget.security - (highTarget.minSec + securityThresh)) / 0.05); //0.05 is a static amount reduced per thread

			if (threads <= 0) {
				ns.print("Invalid order generated: " + type + " " + highTarget.name);
				return Promise.resolve("NO ORDER");
			}
			let ord = new Order(nextOrderID, highTarget, threads, highTarget.minSec + securityThresh, type);
			nextOrderID++;
			return Promise.resolve(new Array(ord)); //return the Order object
		} else if (highTarget.money <= highTarget.maxMoney * moneyThresh) {
			type = "g";
			threads = Math.ceil(ns.growthAnalyze(highTarget.name, highTarget.maxMoney / highTarget.money));

			if (threads <= 0) {
				ns.print("Invalid order generated: " + type + " " + highTarget.name);
				return Promise.resolve("NO ORDER");
			}
			let ord = new Order(nextOrderID, highTarget, threads, highTarget.minSec + securityThresh, type);
			nextOrderID++;
			return Promise.resolve(new Array(ord)); //return the Order object
		} else {
			let orderBatch = new Array();
			type = "h";
			threads = Math.ceil(ns.hackAnalyzeThreads(highTarget.name, highTarget.maxMoney * (1 - moneyThresh)));
			if (threads > hackThreadThresh) {
				threads = hackThreadThresh;
			}
			
			if (threads <= 0) {
				ns.print("Invalid order generated: " + type + " " + highTarget.name);
				return Promise.resolve("NO ORDER");
			}
			
			highTarget.growTime = ns.getGrowTime(highTarget.name);
			highTarget.weakenTime = ns.getWeakenTime(highTarget.name);
			let hackWait = Math.ceil(highTarget.weakenTime - highTarget.hackTime - batchOffset);
			let growWait = Math.ceil(batchOffset + highTarget.weakenTime - highTarget.growTime);
			let weak2Wait = Math.ceil(batchOffset * 2);

			let ord = new Order(nextOrderID, highTarget, threads, highTarget.minSec + securityThresh, type);
			nextOrderID++;
			ord.delay = hackWait;

			let calcThreads = 0;
			//add weak1
			calcThreads = Math.ceil((0.002 * threads) / 0.05);
			let addweak1 = new Order(nextOrderID, highTarget, calcThreads, highTarget.minSec + securityThresh, "w");
			nextOrderID++;
			//add grow
			calcThreads = Math.ceil(ns.growthAnalyze(highTarget.name,
				highTarget.maxMoney / (highTarget.money - (ns.hackAnalyze(highTarget.name) * threads * highTarget.money))));
			let addgrow = new Order(nextOrderID, highTarget, calcThreads, highTarget.minSec + securityThresh, "g");
			nextOrderID++;
			addgrow.delay = growWait;
			//add weak2
			calcThreads = Math.ceil((0.004 * calcThreads) / 0.05);
			let addweak2 = new Order(nextOrderID, highTarget, calcThreads, highTarget.minSec + securityThresh, "w");
			nextOrderID++;
			addweak2.delay = weak2Wait;

			orderBatch.push(addweak1);
			orderBatch.push(addweak2);
			orderBatch.push(addgrow);
			orderBatch.push(ord);

			return Promise.resolve(orderBatch);
		}
	}
}
export class Order {
	target = "";
	threads = 0;
	secThresh = 0;
	id = 0;
	type = ""; //h, g, w
	neededThreads = 0;
	delay = 0;
	constructor(cid, ctarget, cthreads, csecThresh, ctype) {
		this.id = cid;
		this.target = ctarget;
		this.threads = cthreads;
		this.secThresh = csecThresh;
		this.type = ctype;
		this.neededThreads = this.threads;
	}
}